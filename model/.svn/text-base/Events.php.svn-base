<?php

/*

const WARN = 'WARN';
const MSG  = 'MSG';
const INFO  = 'INFO';
const EVENT = 'EVENT';
const ERROR = 'ERROR';
const BLOCK = 'BLOCK';
const FATAL = 'fatal';
*/

/**
 * This is a really dumb fake db for storing events
 */
 
function sortByTime($b, $a){
    if ($a->id == $b->id) {
           return 0;
    }
    //echo('sort...');
    return ($a->id > $b->id) ? 1 : -1;
}
 
class Model_Events {
    
    const datapath = '/tmp/fldata.txt';
    
    protected $data;
    
    //This is a silly silly data store
    public function __construct(){
        if(is_file(self::datapath)){

            $this->data = unserialize(file_get_contents(self::datapath));
        }else{
            $this->data = new stdClass();
            $this->data->events = array();
        }
        
    }
    
    //ok this is a fake api for events, because all events are going to be in log of some kind
    public function addEvent($source, Model_ByUser $owner, $message, $logLevel, $title = 'misc'){
        
        $event = new stdClass();
        $event->id = count($this->data->events);
        $event->time = date('U');
        $event->source = $source;
        $event->owner = $owner;
        $event->title = $title;
        $event->message = $message;
        $event->logLevel = $logLevel;
        
        $this->data->events[] = $event;
        //usort($this->data->events, 'sortByTime');
        
        //this will scale forever dood
        file_put_contents(self::datapath, serialize($this->data));
    }
    
    public function getEvents($count = false){
        
        //this is like, the most efficient code evar. 
       // usort($this->data->events, 'sortByTime');
        
        if(!$count){
            return $this->data->events;
        }
        
        $eventLength = count($this->data->events);
        $retArray = $this->data->events;
        //stick it in the right order...
        usort($retArray, 'sortByTime');

        if($eventLength <= $count){
            
            return $retArray;
        }
        
        $retArray = array();
        for ($i=0; $i < $count; $i++) {
            --$eventLength;
            $thisEvent = $this->data->events[$eventLength];
            $retArray[] = $thisEvent;
        }


        // sortByTime($retArray);
        

        return $retArray;
        
    }
    
    public function getLastEvent(){
        // usort($this->data->events, 'sortByTime');
        
        $count = count($this->data->events);
        if($count > 0){
            return $this->data->events[$count - 1];
        }else{
            return false;
        }
    }
    
    //maybe?
    public function queryEvents(){
        
    }
    
}